#pragma config(Sensor, in1,    marbleID,       sensorReflection)
#pragma config(Sensor, dgtl1,  cupRotate,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  startButton,    sensorTouch)
#pragma config(Sensor, dgtl4,  ledGood,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  ledCaution,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  ledError,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  led3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, led4,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, led5,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, led6,           sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  quadEnc2,       sensorNone)
#pragma config(Motor,  port1,           flashlight,    tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,           marbleGrabber, tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           cupRotater,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           gateServo,     tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                 - ADVANCED Movement by Rotation -                                  *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program uses functions 'TurnLeft(float)' and 'Forward(float)' to very neatly and modularly   *|
|*  run your robot in a square.  There is a two second pause at the beginning of the program.         *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" model, but may not be needed for all robot configurations.                      *|
|*    2)  The values that you pass to the functions, 'Forward(float)' and 'TurnLeft(float)' are then  *|
|*        given to 'r' in each function.                                                              *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor   - Port 2    rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor   - Port 3    leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Digital - Port 1,2  rightEncoder        VEX Quadrature enc.   Right side encoder                *|
|*    Digital - Port 3,4  leftEncoder         VEX Quadrature enc.   Left side encoder                 *|
\*-----------------------------------------------------------------------------------------------4246-*/

// Functions Prototypes
void rotate(float r);
//void TurnLeft(float r);

// Declare Global Variables     /* '_rotations' will be a counter for every 360 encoder clicks */
const float _rotations = 360.0;  /* which is one full rotation of the wheel (ie. 2 '_rotations' */
/* will equal 720.0 clicks, 2 full _rotations of the wheel).   */
//--------------------------------------------| rotate |---------------------------------------------
void rotate(float r)
{
	SensorValue[cupRotate] = 0;    /* Clear the encoders for    */

	// While the encoders have not yet met their goal: (r * _rotations) ie (3.0 * 360.0) or "three _rotations"
	while(SensorValue[cupRotate] < (r * _rotations) && SensorValue[cupRotate] < (r * _rotations))
	{
		motor[cupRotater]  = 63;         /* rotate at half speed. */
	}
	motor[cupRotater]  = 0;            /* can act independantly as a "chunk" of code, without any loose ends. */
}
//----------------------------------------------------------------------------------------------------

//-------------------------------------------| TURN LEFT |--------------------------------------------
//void TurnLeft(float r)
//{
//  SensorValue[cupRotate] = 0;    /* Clear the encoders for    */
//  // While the encoders have not yet met their goal: (left is compared negativly since it will in reverse)
//  while(SensorValue[cupRotate] < (r * _rotations) && SensorValue[leftEncoder] > (-1 * r * _rotations))
//  {
//    motor[cupRotater]  = -63;        // Run the left motor backward at half speed
//  }
//  motor[cupRotater]  = 0;            /* can act independantly as a "chunk" of code, without any loose ends. */
//}
//----------------------------------------------------------------------------------------------------

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
//task main()
//{
//  wait1Msec(2000);        // Wait 2000 milliseconds before continuing.
//
//  int i;
//  for(i=0; i<4; i++)      // While 'i' is less than 4:
//  {
//    Forward(3.0);         // Call function 'Forward(float)' and pass the float value '3.0' through.
//    TurnLeft(1.3);        // Call function 'TurnLeft(float)' and pass the float value '1.3' through.
//  }
//}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  definitions and variables for the motor slew rate controller.              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

#define MOTOR_NUM               kNumbOfTotalMotors
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

// Array to hold requested speed for the motors
int motorReq[ MOTOR_NUM ];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[ MOTOR_NUM ];

// CODEDOC:
// Multitasking - https://www.robotc.net/wikiarchive/Multitasking_tips
// Bumpswitch - http://cdn.robotc.net/pdfs/natural-language/hp_touch.pdf

// QUAD ENCODER - http://cdn.robotc.net/pdfs/vex/curriculum/Quadrature+Encoders.pdf

int i;
int bump;
int count;
int injected;
bool done;
bool scanNow;
bool injectNow;
bool gateOpen;
bool opperateGateNow;
//bool initial = true;

task init()
{
	turnLEDOn(ledError);
	// TurnOff
	turnFlashlightOff(flashlight);
	turnLEDOff(ledGood);
	turnLEDOff(ledCaution);
	turnLEDOff(led1);
	turnLEDOff(led2);
	turnLEDOff(led3);
	turnLEDOff(led4);
	turnLEDOff(led5);
	turnLEDOff(led6);
	stopMotor(marbleGrabber);
	stopMotor(cupRotater);

	SensorValue[cupRotate] = 0;

	//while (initial) {
	//turnLEDOn(ledError);
	// Start Init
	robotType(none);
	turnFlashlightOn(flashlight, 127);
	setServo(gateServo, 10);
	//setServo(gateServo, -100);
	// End Init
	sleep(1000);
	turnLEDOff(ledError);
	turnLEDOn(ledGood);
	//abortTimeslice();
	//}
	
}

task injectMarble() {
	while (true) {
		if (injectNow == true) {
			startMotor(marbleGrabber, -29);
			sleep(300);
			injected = injected + 1;
			stopMotor(marbleGrabber);
			sleep(2800);
			opperateGateNow = false;
		}
		else {
			break;
		}
	}
}

task scanMarble() {
	while (true) {
		if (scanNow == true) {
			//stops the gate untill marble is ready to drop
			opperateGateNow = false;

			sleep(100);

			if ((SensorValue[marbleID] > 185) && (SensorValue[marbleID] < 210)) {
				// Clear Marble
				if(SensorValue[cupRotate] > 0) //Reverse for 5 full rotations
				{
					startMotor(cupRotater, -48);
					untilEncoderCounts(0, cupRotate);
					stopMotor(cupRotater);
				}
				else {
					startMotor(cupRotater, 48);
					untilEncoderCounts(0, cupRotate);
					stopMotor(cupRotater);
				}
			}

			if (SensorValue[marbleID] < 185) {
				// Plastic Marble
				if(SensorValue[cupRotate] > -116) //Reverse for 5 full rotations
				{
					startMotor(cupRotater, -48);
					untilEncoderCounts(-114, cupRotate);
					stopMotor(cupRotater);
				}
				else {
					startMotor(cupRotater, 48);
					untilEncoderCounts(-114, cupRotate);
					stopMotor(cupRotater);
				}
			}

			if (SensorValue[marbleID] > 210) {
				// Wood Marble
				if(SensorValue[cupRotate] > -228) //Reverse for 5 full rotations
				{
					startMotor(cupRotater, -48);
					untilEncoderCounts(-224, cupRotate);
					stopMotor(cupRotater);
				}
				else {
					startMotor(cupRotater, 48);
					untilEncoderCounts(-224, cupRotate);
					stopMotor(cupRotater);
				}
			}

			////sleep(500);
			//startMotor(cupRotater, 48);
			////sleep(200);
			//stopMotor(cupRotater);
			////sleep(100);
			opperateGateNow = true;
			// Reset quadenc cupRotate value
			SensorValue[cupRotate] = 0;
			sleep(500);
		}
		else {
			break;
		}
	}
}

task opperateGate() {
	sleep(2900);
	while (true) {
		sleep(1000);
		while (opperateGateNow == true) {
			if (gateOpen == true) {
				setServo(gateServo, 80);
				sleep(500);
				gateOpen = false;
			}
			if (gateOpen == false) {
				setServo(gateServo, 10);
				sleep(1000);
				gateOpen = true;
			}
		}
	}
}

task ledDebug() {
	while (injected < 16) {
		if (injected == 2) {
			turnLEDOn(led1);
			sleep(250);
			turnLEDOff(led1);
			sleep(250);
			turnLEDOn(led1);
		}
		if (injected == 4) {
			turnLEDOn(led1);
			turnLEDOn(led2);
			sleep(250);
			turnLEDOff(led2);
			sleep(250);
			turnLEDOn(led2);
		}
		if (injected == 7) {
			turnLEDOn(led1);
			turnLEDOn(led2);
			turnLEDOn(led3);
			sleep(250);
			turnLEDOff(led3);
			sleep(250);
			turnLEDOn(led3);
		}
		if (injected == 10) {
			turnLEDOn(led1);
			turnLEDOn(led2);
			turnLEDOn(led3);
			turnLEDOn(led4);
			sleep(250);
			turnLEDOff(led4);
			sleep(250);
			turnLEDOn(led4);
		}
		if (injected == 12) {
			turnLEDOn(led1);
			turnLEDOn(led2);
			turnLEDOn(led3);
			turnLEDOn(led4);
			turnLEDOn(led5);
			sleep(250);
			turnLEDOff(led5);
			sleep(250);
			turnLEDOn(led5);
		}
		if (injected == 14) {
			turnLEDOn(led1);
			turnLEDOn(led2);
			turnLEDOn(led3);
			turnLEDOn(led4);
			turnLEDOn(led5);
			turnLEDOn(led6);
			sleep(250);
			turnLEDOff(led6);
			sleep(250);
			turnLEDOn(led6);
		}
		if (injected == 15) {
			done = true;
		}
	}
}

task main()
{
	//bump = getBumperValue(startButton);

	startTask(init);

	untilTouch(startButton);

	injectNow = true;

	startTask(injectMarble);
	
	scanNow = true;

	startTask(scanMarble);

	
	
	gateOpen = true;

	startTask(ledDebug);


	
	startTask(opperateGate);

	for (count=0; count < 15; count++) {
		waitUntil(opperateGateNow == true);
		sleep(250);
	}

	while (done == false)
	{
		// Keep the program alive
		sleep(1000);

		//rotate(180);
		//sleep(500);
		//stopMotor(cupRotater);
		//sleep(500);

		// FOR MOTOR TESTING PURPOSES
		//startMotor(cupRotater, 127);
		//startMotor(marbleGrabber, 127);
	}

	if (done == true) {
		// Cortex Off - GreenLED on
		turnLEDOff(ledCaution);
		sleep(100);
		turnLEDOff(ledError);
		sleep(100);
		turnLEDOff(led6);
		sleep(100);
		turnLEDOff(led5);
		sleep(100);
		turnLEDOff(led4);
		sleep(100);
		turnLEDOff(led3);
		sleep(100);
		turnLEDOff(led2);
		sleep(100);
		turnLEDOff(led1);
	}
}

//PSEUDOCODETOIMPL
//task main() {
//	while(true)
//	{
//		turnFlashlightOn(flashlight,127);
//		startMotor(marblemotor,15);
//		sleep(200);
//} }
//stopMotor(marblemotor);
//sleep(2000);
//if (SensorValue[lightsensor]>=250) {
//	startMotor(binmotor,40);
//	untilEncoderCounts(110,quad);
//	stopMotor(binmotor);
//	startMotor(marblemotor,20);
//	sleep(200);
//	stopMotor(marblemotor);
//	sleep(1000);
//	stopMotor(marblemotor);
//	startMotor(binmotor,-40);
//	untilEncoderCounts(-105,quad);
//	stopMotor(binmotor);
//	sleep(1000);
//}
